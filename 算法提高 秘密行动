/*
跳跃不花时间但是不能留连续跳 
也就是说 当到达了 i层 i-1层可能是爬上来的 也可能是跳上来的
设f[i][0]为爬上来的，则i-1层可能是爬上来的也可能是跳上来的
设f[i][1]为跳上来的，则i-1层只能是爬上来的（因为跳跃不能连续）
那么状态转移就可以写成
f[i][0] = min(f[i - 1][0], f[i - 1][1]) + a[i]; 这是取上一层跳上来或者爬上来的最小值 然后加上当前楼的高度
		f[i][1] = min(f[i - 1][0], f[i - 2][0]);	因为这是跳上来的 那可能是只跳了一层 也可以是跳两层 选最小的 不需要加高度 因为跳跃不花时间
*/

#include <bits/stdc++.h>
#include <iostream>
#include <algorithm> 
#include <cstring>
using namespace std;

int a[10010];//存储每层楼的高度 
int f[10010][2];//存储爬或跳到某一层所用时间 

int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	//memset(f,0,sizeof(f));
	f[1][0] = a[1];//爬到第一层所用时间 
	f[1][1] = 0;//跳到第一层所用时间 
	for (int i = 2; i <= n; i++)
	{
		f[i][0] = min(f[i - 1][0], f[i - 1][1]) + a[i];//如果第i层是爬上来的，则上一层可以是爬上来的也可以是跳上来的 
		f[i][1] = min(f[i - 1][0], f[i - 2][0]);//如果第i层是跳上来的，则上一层一定是爬上来的 
	}
	cout << min(f[n][0], f[n][1]) << endl;
	return 0;
}
